// NOLINTBEGIN
/*
 _______ _________ _______  _______
(  ____ \\__   __/(  ___  )(  ____ )
| (    \/   ) (   | (   ) || (    )|
| (_____    | |   | |   | || (____)|
(_____  )   | |   | |   | ||  _____)
      ) |   | |   | |   | || (
/\____) |   | |   | (___) || )
\_______)   )_(   (_______)|/

This file was generated by Claude Haiku
It should only ever be used when include/utils/str_utils.hpp includes it towards the end of the file

*/

#pragma once

#include <string>

/**
 * Counts the number of emojis in a UTF-8 encoded string.
 *
 * This function correctly handles:
 * - Basic emojis (ðŸ˜€, ðŸŒ, ðŸš€)
 * - Consecutive emojis without separators
 * - Regional indicator pairs (flags like ðŸ‡ºðŸ‡¸, ðŸ‡¬ðŸ‡§)
 * - ZWJ (Zero Width Joiner) sequences (ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦, ðŸ‘¨â€ðŸ’», ðŸ³ï¸â€ðŸŒˆ)
 * - Emoji modifiers (skin tones like ðŸ‘‹ðŸ»)
 * - Keycap sequences (1ï¸âƒ£, #ï¸âƒ£, *ï¸âƒ£)
 * - Variation selectors (VS16)
 *
 * @param str UTF-8 encoded string to analyze
 * @return Number of emojis found in the string
 *
 * FIXES APPLIED:
 * 1. Fixed consecutive emoji counting - Added peekCP helper to avoid consuming
 *    subsequent emojis when checking for modifiers/VS16
 * 2. Fixed ZWJ sequence handling - Properly tracks position advancement through
 *    ZWJ sequences to count them as single emojis
 */

[[nodiscard]] static int countEmojis(const std::string& str) {
  // Lambda to decode the next UTF-8 codepoint and advance the index
  auto nextCP = [&](size_t& idx) -> unsigned int {
    const size_t len = str.size();
    if (idx >= len) return 0;
    const unsigned char* s = reinterpret_cast<const unsigned char*>(str.data());
    unsigned char c = s[idx];

    // 1-byte sequence (ASCII)
    if (c < 0x80) {
      idx += 1;
      return c;
    }

    // 2-byte sequence
    if ((c >> 5) == 0x6) {
      if (idx + 1 >= len) {
        idx = len;
        return 0;
      }
      unsigned int cp = ((c & 0x1F) << 6) | (s[idx + 1] & 0x3F);
      idx += 2;
      return cp;
    }

    // 3-byte sequence
    if ((c >> 4) == 0xE) {
      if (idx + 2 >= len) {
        idx = len;
        return 0;
      }
      unsigned int cp = ((c & 0x0F) << 12) | ((s[idx + 1] & 0x3F) << 6) | (s[idx + 2] & 0x3F);
      idx += 3;
      return cp;
    }

    // 4-byte sequence
    if ((c >> 3) == 0x1E) {
      if (idx + 3 >= len) {
        idx = len;
        return 0;
      }
      unsigned int cp = ((c & 0x07) << 18) | ((s[idx + 1] & 0x3F) << 12) |
                        ((s[idx + 2] & 0x3F) << 6) | (s[idx + 3] & 0x3F);
      idx += 4;
      return cp;
    }

    // Invalid UTF-8 byte, skip it
    idx += 1;
    return 0;
  };

  // Lambda to peek at the next codepoint without advancing the index
  // CRITICAL FIX: This prevents consuming subsequent emojis when checking for modifiers
  auto peekCP = [&](size_t idx) -> unsigned int {
    size_t temp = idx;
    return nextCP(temp);
  };

  // Check if codepoint is a regional indicator (for flags)
  auto isRegional = [](unsigned int cp) -> bool { return cp >= 0x1F1E6u && cp <= 0x1F1FFu; };

  // Check if codepoint is an emoji modifier (skin tone)
  auto isEmojiModifier = [](unsigned int cp) -> bool { return cp >= 0x1F3FBu && cp <= 0x1F3FFu; };

  // Check if codepoint is a base emoji character
  auto isEmojiBase = [](unsigned int cp) -> bool {
    return (cp >= 0x1F600u && cp <= 0x1F64Fu) ||  // emoticons
           (cp >= 0x1F300u && cp <= 0x1F5FFu) ||  // symbols & pictographs
           (cp >= 0x1F680u && cp <= 0x1F6FFu) ||  // transport & map
           (cp >= 0x2600u && cp <= 0x26FFu) ||    // misc symbols
           (cp >= 0x2700u && cp <= 0x27BFu) ||    // dingbats
           (cp >= 0x1F900u && cp <= 0x1F9FFu) ||  // supplemental
           (cp >= 0x1FA70u && cp <= 0x1FAFFu) ||  // extended-A
           (cp == 0x00A9u) || (cp == 0x00AEu) || (cp == 0x203Cu) || (cp == 0x2049u) ||
           (cp == 0x3030u) || (cp == 0x303Du);
  };

  const unsigned int ZWJ = 0x200Du;     // Zero Width Joiner
  const unsigned int VS16 = 0xFE0Fu;    // Variation Selector-16 (emoji presentation)
  const unsigned int KEYCAP = 0x20E3u;  // Combining Enclosing Keycap

  size_t i = 0;
  int count = 0;
  const size_t len = str.size();

  while (i < len) {
    size_t cur = i;
    unsigned int cp = nextCP(cur);
    if (cp == 0) {
      i = cur;
      continue;
    }

    // Handle regional indicator pairs (flags)
    if (isRegional(cp)) {
      size_t peek = cur;
      unsigned int cp2 = nextCP(peek);
      if (cp2 != 0 && isRegional(cp2)) {
        // Two regional indicators = one flag emoji
        count += 1;
        i = peek;
        continue;
      } else {
        // Single regional indicator (shouldn't normally happen)
        count += 1;
        i = cur;
        continue;
      }
    }

    // Handle keycap sequences: (0-9, #, *) + VS16? + KEYCAP
    if ((cp >= 0x30u && cp <= 0x39u) || cp == 0x23u || cp == 0x2Au) {
      size_t peek = cur;
      unsigned int a = nextCP(peek);
      if (a == VS16) {
        unsigned int b = nextCP(peek);
        if (b == KEYCAP) {
          count += 1;
          i = peek;
          continue;
        }
      } else if (a == KEYCAP) {
        count += 1;
        i = peek;
        continue;
      }
      // Otherwise not an emoji keycap sequence, fall through
    }

    // Handle emoji base characters and complex sequences
    if (isEmojiBase(cp) || cp == VS16) {
      size_t k = cur;  // k tracks position after consuming emoji components

      // Check for optional variation selector (VS16)
      if (peekCP(k) == VS16) {
        nextCP(k);  // consume it
      }

      // Check for optional emoji modifier (skin tone)
      if (peekCP(k) != 0 && isEmojiModifier(peekCP(k))) {
        nextCP(k);  // consume the modifier
      }

      // Handle ZWJ (Zero Width Joiner) sequences
      // CRITICAL FIX: Properly track advancement through entire ZWJ sequence
      // Examples: ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ (family), ðŸ‘¨â€ðŸ’» (man technologist),
      // ðŸ³ï¸â€ðŸŒˆ (rainbow flag)
      while (peekCP(k) == ZWJ) {
        size_t temp_k = k;
        nextCP(temp_k);  // consume ZWJ

        unsigned int follow = peekCP(temp_k);

        // Check if what follows ZWJ is another emoji component
        if (follow != 0 && (isEmojiBase(follow) || isRegional(follow))) {
          nextCP(temp_k);  // consume the following emoji

          // Consume optional VS16 after the component
          if (peekCP(temp_k) == VS16) {
            nextCP(temp_k);
          }

          // Consume optional modifier after the component
          if (peekCP(temp_k) != 0 && isEmojiModifier(peekCP(temp_k))) {
            nextCP(temp_k);
          }

          k = temp_k;  // commit the advancement
        } else {
          // Not a valid ZWJ sequence component, stop here
          break;
        }
      }

      count += 1;
      i = k;  // Move to position after the complete emoji sequence
      continue;
    }

    // Not recognized as emoji, move to next codepoint
    i = cur;
  }

  return count;
}

// NOLINTEND